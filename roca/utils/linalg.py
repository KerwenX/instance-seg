import numpy as np
import quaternion
import torch

from pytorch3d.structures import Meshes


def make_M_from_tqs(t: list, q: list, s: list, center=None) -> np.ndarray:
    if not isinstance(q, np.quaternion):
        q = np.quaternion(q[0], q[1], q[2], q[3])
    T = np.eye(4)
    T[0:3, 3] = t
    R = np.eye(4)
    R[0:3, 0:3] = quaternion.as_rotation_matrix(q)
    S = np.eye(4)
    S[0:3, 0:3] = np.diag(s)

    C = np.eye(4)
    if center is not None:
        C[0:3, 3] = center

    M = T.dot(R).dot(S).dot(C)
    return M


def decompose_mat4(M: np.ndarray) -> tuple:
    R = M[0:3, 0:3].copy()
    sx = np.linalg.norm(R[0:3, 0])
    sy = np.linalg.norm(R[0:3, 1])
    sz = np.linalg.norm(R[0:3, 2])

    s = np.array([sx, sy, sz])

    R[:, 0] /= sx
    R[:, 1] /= sy
    R[:, 2] /= sz

    q = quaternion.as_float_array(quaternion.from_rotation_matrix(R[0:3, 0:3]))
    # q = quaternion.from_float_array(quaternion_from_matrix(M, False))

    t = M[0:3, 3]
    return t, q, s


def transform_mesh(
    meshes: Meshes,
    t: list,
    q: np.quaternion,
    s: list
) -> Meshes:
    assert len(meshes) == 1, 'Batched evaluation is not supported yet'
    mat = make_M_from_tqs(t, q, s)
    pts = meshes.verts_list()[0].numpy()
    pts = np.hstack([pts, np.ones((pts.shape[0], 1))])
    pts = pts @ mat.T
    return Meshes([torch.from_numpy(pts[:, :3]).float()], meshes.faces_list())
